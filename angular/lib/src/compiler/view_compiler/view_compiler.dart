import 'package:meta/meta.dart';
import 'package:source_span/source_span.dart';
import 'package:angular_compiler/cli.dart';

import '../compile_metadata.dart'
    show CompileDirectiveMetadata, CompileTypedMetadata, CompilePipeMetadata;
import '../expression_parser/parser.dart';
import '../identifiers.dart';
import '../output/output_ast.dart' as o;
import '../parse_util.dart' show ParseErrorLevel;
import '../schema/element_schema_registry.dart';
import '../template_ast.dart' show TemplateAst, templateVisitAll;
import 'compile_element.dart' show CompileElement;
import 'compile_view.dart' show CompileView;
import 'view_binder.dart' show bindView, bindViewHostProperties;
import 'view_builder.dart';
import 'view_compiler_utils.dart' show getHostViewFactoryName;

class ViewCompileResult {
  List<o.Statement> statements;
  ViewCompileResult(this.statements);
}

/// Compiles a single component to a set of CompileView(s) and generates top
/// level statements to support debugging and view factories.
///
/// - Creates main CompileView
/// - Runs ViewBuilderVisitor over template ast nodes
///     - For each embedded template creates a child CompileView and recurses.
/// - Builds a tree of CompileNode/Element(s)
class ViewCompiler {
  final CompilerFlags _genConfig;
  final ElementSchemaRegistry _schemaRegistry;
  Parser parser;

  ViewCompiler(this._genConfig, this.parser, this._schemaRegistry);

  ViewCompileResult compileComponent(
      CompileDirectiveMetadata component,
      List<TemplateAst> template,
      o.Expression styles,
      List<CompileTypedMetadata> directiveTypes,
      List<CompilePipeMetadata> pipes,
      Map<String, String> deferredModules,
      {@required bool registerComponentFactory}) {
    var statements = <o.Statement>[];
    var view = CompileView(component, _genConfig, directiveTypes, pipes, styles,
        0, CompileElement.root(), [], deferredModules);
    _buildView(view, template);
    // Need to separate binding from creation to be able to refer to
    // variables that have been declared after usage.
    bindView(view, template);
    _bindHostProperties(view);
    _finishView(view, statements,
        registerComponentFactory: registerComponentFactory);
    return ViewCompileResult(statements);
  }

  void _bindHostProperties(CompileView view) {
    var errorHandler =
        (String message, SourceSpan sourceSpan, [ParseErrorLevel level]) {
      if (level == ParseErrorLevel.FATAL) {
        throwFailure(message);
      } else {
        logWarning(message);
      }
    };
    bindViewHostProperties(view, parser, _schemaRegistry, errorHandler);
  }

  /// Builds the view and returns number of nested views generated.
  void _buildView(CompileView view, List<TemplateAst> template) {
    var builderVisitor = ViewBuilderVisitor(view);
    templateVisitAll(builderVisitor, template,
        view.declarationElement.parent ?? view.declarationElement);
  }

  /// Creates top level statements for main and nested views generated by
  /// buildView.
  void _finishView(CompileView view, List<o.Statement> targetStatements,
      {@required bool registerComponentFactory}) {
    view.afterNodes();
    _createViewTopLevelStmts(view, targetStatements,
        registerComponentFactory: registerComponentFactory);
    int nodeCount = view.nodes.length;
    var nodes = view.nodes;
    for (int i = 0; i < nodeCount; i++) {
      var node = nodes[i];
      if (node is CompileElement &&
          node.embeddedView != null &&
          !node.embeddedView.isInlined) {
        _finishView(node.embeddedView, targetStatements,
            registerComponentFactory: false);
      }
    }
  }

  void _createViewTopLevelStmts(
      CompileView view, List<o.Statement> targetStatements,
      {@required bool registerComponentFactory}) {
    final viewClass = createViewClass(view, parser);
    targetStatements
      ..add(viewClass)
      ..add(createViewFactory(view, viewClass))
      ..addAll(registerComponentFactory ? _registerComponentFactory(view) : []);
  }

  // Adds const _FooNgFactory = const ComponentFactory<Foo>(...).
  // ComponentFactory<Foo> FooNgFactory get _FooNgFactory;
  //
  // This is referenced in `initReflector/METADATA` and by user-code.
  List<o.Statement> _registerComponentFactory(CompileView view) {
    var statements = <o.Statement>[];
    var compMeta = view.component;
    var compFactoryVar = '${compMeta.type.name}NgFactory';
    var hostViewFactoryVar = getHostViewFactoryName(compMeta);
    var factoryType = [o.importType(compMeta.type)];
    statements.add(o
        .variable('_$compFactoryVar')
        .set(o.importExpr(Identifiers.ComponentFactory).instantiate(
          <o.Expression>[
            o.literal(compMeta.selector),
            o.variable(hostViewFactoryVar),
          ],
          type: o.importType(
            Identifiers.ComponentFactory,
            factoryType,
            [o.TypeModifier.Const],
          ),
        ))
        .toDeclStmt(null, [o.StmtModifier.Const]));

    statements.add(
      o.fn(
        // No parameters.
        [],
        // Statements.
        [
          o.ReturnStatement(o.ReadVarExpr('_$compFactoryVar')),
        ],
        o.importType(
          Identifiers.ComponentFactory,
          factoryType,
        ),
      ).toGetter('$compFactoryVar'),
    );

    return statements;
  }
}
