import 'package:meta/meta.dart';
import 'package:angular/src/compiler/expression_parser/parser.dart';
import 'package:angular/src/compiler/identifiers.dart';
import 'package:angular/src/compiler/ir/model.dart' as ir;
import 'package:angular/src/compiler/output/output_ast.dart' as o;
import 'package:angular/src/compiler/schema/element_schema_registry.dart';
import 'package:angular/src/compiler/template_ast.dart' show templateVisitAll;
import 'package:angular/src/core/linker/view_type.dart';
import 'package:angular_compiler/cli.dart';

import 'compile_element.dart' show CompileElement;
import 'compile_view.dart' show CompileView;
import 'view_binder.dart' show bindView;
import 'view_builder.dart';
import 'view_compiler_utils.dart' show getHostViewFactoryName;

class ViewCompileResult {
  List<o.Statement> statements;
  ViewCompileResult(this.statements);
}

/// Compiles a single component to a set of CompileView(s) and generates top
/// level statements to support debugging and view factories.
///
/// - Creates main CompileView
/// - Runs ViewBuilderVisitor over template ast nodes
///     - For each embedded template creates a child CompileView and recurses.
/// - Builds a tree of CompileNode/Element(s)
class ViewCompiler {
  final CompilerFlags _genConfig;
  final ElementSchemaRegistry _schemaRegistry;
  Parser parser;

  ViewCompiler(this._genConfig, this.parser, this._schemaRegistry);

  ViewCompileResult compileComponent(
    ir.View view,
    o.Expression styles,
    Map<String, String> deferredModules, {
    @required bool registerComponentFactory,
  }) {
    var statements = <o.Statement>[];
    var compileView = CompileView(
      view.cmpMetadata,
      _genConfig,
      view.directiveTypes,
      view.pipes,
      styles,
      0,
      CompileElement.root(),
      [],
      deferredModules,
    );
    view.compileView = compileView;
    _buildView(view);
    // Need to separate binding from creation to be able to refer to
    // variables that have been declared after usage.
    bindView(view, _schemaRegistry, bindHostProperties: true);
    _finishView(compileView, statements,
        registerComponentFactory: registerComponentFactory);
    return ViewCompileResult(statements);
  }

  /// Builds the view and returns number of nested views generated.
  void _buildView(ir.View view) {
    var builderVisitor = ViewBuilderVisitor(view.compileView);
    templateVisitAll(
      builderVisitor,
      view.parsedTemplate,
      view.compileView.declarationElement,
    );
    view.compileView.providers = builderVisitor.providers;
  }

  /// Creates top level statements for main and nested views generated by
  /// buildView.
  void _finishView(CompileView view, List<o.Statement> targetStatements,
      {@required bool registerComponentFactory}) {
    view.afterNodes();
    _createViewTopLevelStmts(view, targetStatements,
        registerComponentFactory: registerComponentFactory);
    int nodeCount = view.nodes.length;
    var nodes = view.nodes;
    for (int i = 0; i < nodeCount; i++) {
      var node = nodes[i];
      if (node is CompileElement && node.embeddedView != null) {
        _finishView(
          node.embeddedView,
          targetStatements,
          registerComponentFactory: false,
        );
      }
    }
  }

  void _createViewTopLevelStmts(
      CompileView view, List<o.Statement> targetStatements,
      {@required bool registerComponentFactory}) {
    final viewClass = createViewClass(view, parser);
    if (view.viewIndex == 0) {
      targetStatements
          .add(o.CommentStmt('${view.component.type.isHost ? 'Host' : 'View'} '
              'for component ${view.component.toPrettyString()}'));
    }
    targetStatements.add(viewClass);
    if (view.viewType != ViewType.component) {
      // View factories are only needed for embedded and host views, to be used
      // by `TemplateRef` and `ComponentFactory` respectively.
      targetStatements.add(createViewFactory(view, viewClass));
    }
    targetStatements.addAll(
        registerComponentFactory ? _registerComponentFactory(view) : []);
  }

  // Adds const _FooNgFactory = const ComponentFactory<Foo>(...).
  // ComponentFactory<Foo> FooNgFactory get _FooNgFactory;
  //
  // This is referenced in `initReflector/METADATA` and by user-code.
  List<o.Statement> _registerComponentFactory(CompileView view) {
    var statements = <o.Statement>[];
    var compMeta = view.component;
    var compFactoryVar = '${compMeta.type.name}NgFactory';
    var hostViewFactoryVar = getHostViewFactoryName(compMeta);
    var factoryType = [o.importType(compMeta.type)];
    statements.add(o
        .variable('_$compFactoryVar')
        .set(o.importExpr(Identifiers.ComponentFactory).instantiate(
          <o.Expression>[
            o.literal(compMeta.selector),
            o.variable(hostViewFactoryVar),
          ],
          type: o.importType(
            Identifiers.ComponentFactory,
            factoryType,
            [o.TypeModifier.Const],
          ),
        ))
        .toDeclStmt(null, [o.StmtModifier.Const]));

    statements.add(
      o.fn(
        // No parameters.
        [],
        // Statements.
        [
          o.ReturnStatement(o.ReadVarExpr('_$compFactoryVar')),
        ],
        o.importType(
          Identifiers.ComponentFactory,
          factoryType,
        ),
      ).toGetter('$compFactoryVar'),
    );

    return statements;
  }
}
